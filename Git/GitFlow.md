# GIT FLOW LEXWEB STUDIO



<img style="float: right;" src="/Git/LexWeb%20logo.png">


### СТАРТ ПРОЕКТА

#### 1.1 Чтобы выгрузить свой проект на удалённый репозиторий нужно:
Создать удалённый репозиторий на битбакете (или гитхабе, или на другом удобном ресурсе) и в терминале
находясь в папке локального репозитория пишем:

```<language>
git remote add origin ССЫЛКА_НА_РЕПОЗИТОРИЙ
git push -u origin master
```
#### 1.2 Получение существующего удалённого репозитория на локалку.

 Находясь в папке, где хранятся все проекты на компе пишем команду:

```<language>
git clone ССЫЛКА_НА_РЕПОЗИТОРИЙ  
```
 
например

```<language>
git clone https://alexkrasilnikov@bitbucket.org/alexkrasilnikov/nuxt-lexwebstudio.git
```

Или используем инструменты IDE

#### 2. Сразу же после клонирования уходим из ветки `DEVELOP`, а тем более из `MASTER`

Ветка `MASTER` – только для итоговой финальной утверждённой версии проекта, которую
увидит юзер и/или заказчики.<br>
Ветка `DEVELOP` – только для готовых утверждённых фич, которые хотим увидеть на
актуальной девелоперской версии, но которую пока не хотим показывать заказчику. Это
типа как пред-тестовый сервер, для тех фич, которые вроде готовы, но надо проверить
перед показом.

#### 2.1.1. Когда можно заливать коммиты напрямую в `MASTER?`

**Никогда**

#### 2.1.2. Когда запрещено заливать коммиты напрямую в `MASTER?`

**Всегда.**

#### 2.2.1. Когда можно заливать коммиты напрямую в `DEVELOP?`

Суть такова, что если нужно пофиксить маленький баг `CSS` стиля, или пару слов
в тексте сайта, или баг, которого нет в задаче, но ты о нём знаешь, и он очень
маленький, относится к прошлым уже сданным задачам или просто обязан
быть в официальной версии, но по какой-то причине получился косяк – тогда
коммит можно делать напрямую в DEVELOP

#### 2.2.2. Когда запрещено заливать коммиты напрямую в `DEVELOP`

Если для задачи была опубликована задача в таск-менеджере, если
разрабатывается серьёзная крупная фича, сайт меняется по дизайну,
существенно перерабатывается уже существующий функционал – тогда
никогда не коммитим в `DEVELOP`, а после создания новой ветки и завершения
работы над ней – push-ым её на удалённый репозиторий.

```<language>
git push
```

#### 3. Создание новой ветки.

Мы увидели задачу в TRELLO и клонировали проект – что дальше?<br>
Дальше сразу же создаётся новая ветка, независимо от того, будет это потом коммититься в `DEVELOP` или нет –
***ВСЕГДА создаём новую ветку!***

Как назвать ветку?

Во-первых, конечно, она пишется на инглише.<br>
Во-вторых, название ВСЕГДА состоит из 3-x частей:<br>

`ИНИЦИАЛЫ_УЧАСТНИКА/КОРОТКО-НАЗВАНИЕ-ЗАДАЧИ-НОМЕР-ЗАДАЧИ`


Примеры:

Меня зовут Павел Бабич, задача над которой я работаю называется «Добавить для членов
опцию Исполняющий обязанности главы», номер задачи в Trello #119
Значит я называю ветку так: 

`pb/io-membership-119`

Меня зовут Александр Красильников, задача над которой я работаю называется:<br>
«Проработать архитектурно посты и комментарии, придумать UI/UX», номер задачи в Trello #125<br>
Значит я называю ветку так:

` ak/forum-posts-125`

Меня зовут Вася Пупкин, задача над которой я работаю называется:<br>
«Update Order Of Project Details Screen UI», номер задачи на GitHub #259<br>
Значит я называю ветку так:

` vp/project-details-order-ui-259`

Слэш нужен, чтобы все ветки разбивались по папкам на каждого участника

#### 4. Коммиты.

В одной задаче у нас может быть много подзадач, которые легче коммитить почаще, чтобы
если что возвращаться в более ранние версии и было проще отследить, где и на какой фазе
был косяк.

Допустим, называется задача «Сделать адаптивность главной страницы», под номером #123<br>
c чек-листом из трёх подзадач:<br>
 - «Адаптивный хэдер», 
 - «Адаптивный контент» 
 - «Адаптивныйфутер».
 
Создаём ветку:

`ak/main-page-responsive-123`

C такими коммитами (их может быть больше, сколько захочешь, в конце каждой подзадачи):

- Mainpage Responsive Header #123
- Mainpage Responsive Content #123
- Mainpage Responsive Footer #123

Т.е. на инглише в произвольном формате даём понять где была проблема, которой ты
занимался, и для какой задачи (номер) это было. На ГитХабе эта привычка, например,
поможет по тегам #123 перемещаться в саму таску.

#### 5. Что делать, когда задача завершена?

Есть 2 пути:

 -  это был маленький фикс, и нужно запушить в девелоп, 
 -  либо это была задача из трелло (или какая-то супер-пупер фича).

В первом случае действия будут такие:

#### 5.1. Мы должны закинуть коммит в `DEVELOP` ветку.

Но перед этим нужно проверить, не запушил ли кто-то уже туда свой коммит.
Для этого нужно перейти из твоей текущей ветки

`(например ak/main-page-responsive-123)`

 в `DEVELOP`

нажать в IDE (или на чём ты там сидишь)

```<language>
fetch 
```

 Проверит удаленный репозиторий на наличие обновлений.<br>
Если `DEVELOP` таки обновился, пока ты занимался своей задачей – значит делаем **PULL** новых
коммитов `DEVELOP` и мержим `DEVELOP` в `ak/main-page-responsive-123`

Для этого находясь в `DEVELOP`  делаем
```<language>
 git pull
```
 затем переключаемся в ak/main-pageresponsive-123 и делаем:

```<language>
 git merge develop
```

В итоге ветка `ak/main-page-responsive-123` имеет твои новые коммиты и новые коммиты с
удалённого репозитория ветки `DEVELOP`, а удалённый `DEVELOP` не имеет твоих новых
коммитов.

Теперь переходим в `DEVELOP` и мержим коммиты из `ak/main-page-responsive-123`
находясь в `DEVELOP` делаем:

```<language>
 git merge ak/main-page-responsive-123
```

Всё, ветка `DEVELOP` имеет и старые и новые коммиты, и те которые были на удалёнке –
значит можно пушить локальный `DEVELOP` в удалённый `DEVELOP`

```<language>
git push
```
#### 5.2. Если разрабатывалась крупная задача, фича, серьёзные доработки

В таком случае  нужно запушить текущую ветку на удалёнку как есть.


Для этого после закоммиченной задачи, когда все работы по текущей фиче завершены
– просто делаешь: 

```<language>
 git push
```
Будем работать без `pull request-ов`, просто в коммент задачи скидывай ссылку на
удалённую ветку и всё. Я на локалке буду проверять задачу, выписывать баги – и
просто будем продолжать фиксить в эту ветку, пока она реально не будет готова к
релизу в `DEVELOP`

#### 6. Наследственность веток (родительские ветки).
Важно то, что возможно задач по какому-то этапу сайта так много, что для одного
глобального этапа нужны не только коммиты, а несколько веток.

Для этого лучше понимать,что перед `DEVELOP` есть ветка посредник.
К примеру, трудимся мы над страницей контактов и в разное время приходят разные задачи по
этой странице.
Когда-то была общая ветка `ak/contacts-ui-234`, которую из-за неготовности
мы так и не вмержили в `DEVELOP`.<br>

Пришла задача по внедрению карты `ak/contacts-map-235`,
через неделю пришла задача по соц. сетям `ak/contacts-networks-236` и так далее.

Мы не будем каждый раз брать свежую инфу из `DEVELOP` так как это можно сойти с ума. На
практике мы знаем, что есть ответственная за страницу контактов ветка `ak/contacts-ui-234` с
которой всё началось.<br>
Поэтому, когда завершили работу по всему что связано с картой `ak/contacts-map-23` – сразу
же её мержим в `ak/contacts-ui-234`, т.е. переходим в `ak/contacts-ui-234` и пишем 
```<language>
git merge ak/contacts-map-235
```
 И всё, и забываем о карте. Она уже есть в родительской ветке.
Потом, когда завершаем работу над `ak/contacts-networks-236` – тоже самое, переходим в
`ak/contacts-ui-234` и пишем
```<language>
 git merge ak/contacts-networks-236
```
И когда понимаем, что всё, мы всё сделали, для того чтобы все были довольны страницей
контактов – я сам мержу `ak/contacts-ui-234` в `DEVELOP`, т.е. находясь в `DEVELOP` пишу
```<language>
 git merge ak/contacts-ui-234
```
 (в котором будут и первые коммиты `ak/contacts-ui-234` и коммиты
`ak/contacts-map-235` и коммиты `ak/contacts-networks-236`). При этом, конечно, может быть куча
конфликтов, но это уже отдельная история.

#### 7. Как решать merge конфликты.

Может случиться так, что в случае п 5.1. может в итоге оказаться, что два участника проекта
работали с одной и той же строчкой кода, и хэш не понял, что это разные изменения, и
решил не делать это в жёстком режиме, а просит, чтобы человек это решил сам.

В этом случае, когда в терминале пишется «автомерж не сработал, решите конфликт
вручную» нужно написать
```<language>
 git mergetool
```
Далее откроется окно программы, с помощью которой всё это решается так (можешь сразу на
шестую минуту перематывать):

[Как решить merge конфликт](https://1drv.ms/v/s!Aq6Zzwenb7c5rRgOKGqRAcC6t2nl)

Чтоб это всё работало, нужно одноразово сделать такую процедуру:

Скачать тут: http://meldmerge.org

Установить (без сюрпризов, легковесная прога).
После установки зайти в терминал и единоразово добавить МЕЛД в конфиг двумя командами по очереди:
```<language>
git config --global merge.tool meld
git config --global mergetool.meld.path "путь…C:\Program files (x86)\meld\...путь к мелду"
```
ИТОГ (версия работы в GIT на 31 марта 2020г.):

####  1. ВЕТКА TESTING:  

КОНЕЧНАЯ для нас двоих общая ветка - пусть будет ветка TESTING. Т.е. всегда, когда задача
попадает из IN PROGRESS в QA TESTING независимо от того, в какой ветке ты работал - изменения
должны быть доступны в ветке TESTING. Я её скачиваю, и получаю всю последнюю историю по
всем-всем веткам на проекте. Свои локальные ветки (admin, front, и неважно что там - МОЖЕШЬ
ДАЖЕ НЕ ПУБЛИКОВАТЬ НА БИТБАКЕТ, если ты работаешь с разных мест - то пожалуйста, но я их
качать не буду, они твои. точно также как и мои локальные ветки - не должны передаваться комуто, это мои ветки на то и мои, что в них идёт работа по разным фичам, как мне удобно)

#### 2. ВЕТКА DEVELOP:
Когда какая-то задача прошла тестирование - мержится в девелоп (через пулл-реквест, при
определённых условиях можешь ты, а можем мержить просто на компе, при определённых
обстоятельствах, в условиях спешки на других проектах или на этом). Тут финальная сборка сайта,
но которую ещё нельзя показывать юзерам, или которая ещё не видна юзерам на официальном
домене.

#### 3. ВЕТКА MASTER:
Продакшн-версия сайта, доступная по официальному домену, адресу сайта

Всё, другие ветки разработчикам больше не нужны, не нужно просто так (если не для себя) пушить
всё подряд, весь своё хлам по каждой задаче для других разработчиков. Всё своё - держи у себя
на локалке, организовывай как хочешь. Задача команды - опубликовать изменения в TESTING
ветке, чтобы принять это на другом компе.

Т.е. GITFLOW таков: доделал задачу (например в ветке `pb/create-admin-panel`), закоммитил,
дальше переключился на ветку TESTING, проверяю нет ли там новых изменений (делаю git
fetch, или git pull, кароче обновляешь теми инструментами, что у тебя в редакторе доступны), 
сделал слияние веток `pb/create-admin-panel` в `TESTING`, и запушил `TESTING` на битбакет. В Трелло
передвигаешь карточку в Тестинг
Другой программер (я например) стягиваю TESTING, отпочковываюсь на `ak/bla-bla-branch` и делаю
там всё что хочу. После того как сделать изменения, я переключаюсь на `TESTING`, проверяю
```<language>
 git fetch
```
 не было ли новых изменений, пока я ковырялся, делаю слияние веток
```<language>
git merge
```
 из `ak/blabla-branch` в `TESTING` и закидываю её на битбакет.
Если это была конечная правка задачи, я сам делаю пулл-реквест, сливаю `TESTING` в `DEVELOP` и
довольный переставляю задачу в трелло в ПРЕ-РЕЛИЗ ТЕСТИРОВАНИЕ
Когда все задачи в `DEVELOP` уже обкатаны вдоль и поперёк, делается пулл-реквест `DEVELOP` в
`MASTER`, и проект закидывается онлайн. Карточка в трелло переходит в `DONE`

